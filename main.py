from __future__ import annotations
"""Entry point for WoL-only Telegram bot.
Run: python -m main  (or python main.py)
"""
import asyncio
import logging
import logging.handlers
import random
from pathlib import Path
from typing import Dict, List, Optional
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.error import BadRequest
from telegram.ext import Application, CallbackQueryHandler, CommandHandler, ContextTypes
from src.config import Host, Settings, load_settings
from src.wol import send_magic_packet
logger = logging.getLogger("wolbot")
FACTS = [
    "–í—ã –∑–Ω–∞–ª–∏? –ï—Å–ª–∏ —É–¥–∞—Ä–∏—Ç—å –ø–æ —Å–∏—Å—Ç–µ–º–Ω–æ–º—É –±–ª–æ–∫—É ‚Äî –æ–Ω –Ω–µ –≤–∫–ª—é—á–∏—Ç—Å—è –±—ã—Å—Ç—Ä–µ–µ.",
    "–§–∞–∫—Ç: 90% –ø—Ä–æ–±–ª–µ–º —Ä–µ—à–∞—é—Ç—Å—è –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–æ–π. –û—Å—Ç–∞–ª—å–Ω—ã–µ 10% ‚Äî —Ç–æ–∂–µ.",
    "–ó–∞–±–∞–≤–Ω—ã–π —Ñ–∞–∫—Ç: MAC –Ω–µ –ø—Ä–æ —è–±–ª–æ–∫–∏, –∞ –ø—Ä–æ —Å–µ—Ç–µ–≤—ã–µ –∫–∞—Ä—Ç—ã.",
    "–í—ã –∑–Ω–∞–ª–∏? Wake-on-LAN –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –±–µ–∑ —Ç–∞–Ω—Ü–µ–≤ —Å NAT.",
    "–§–∞–∫—Ç: –ï—Å–ª–∏ –¥–æ–ª–≥–æ —Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –ü–ö, –æ–Ω –±—ã—Å—Ç—Ä–µ–µ –Ω–µ –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è.",
    "–°–æ–≤–µ—Ç: –õ—é–±–∏—Ç–µ —Å–≤–æ–π SSD, –∏ –æ–Ω –æ—Ç–≤–µ—Ç–∏—Ç —Å–∫–æ—Ä–æ—Å—Ç—å—é.",
    "–õ–∞–π—Ñ—Ö–∞–∫: –ù–µ —Ö—Ä–∞–Ω–∏—Ç–µ –ø–∞—Ä–æ–ª–∏ –≤ passwords.txt –Ω–∞ —Ä–∞–±–æ—á–µ–º —Å—Ç–æ–ª–µ.",
    "–§–∞–∫—Ç: –õ—é–±–æ–π '–±—ã—Å—Ç—Ä—ã–π —Ñ–∏–∫—Å' –∂–∏–≤—ë—Ç –¥–æ–ª—å—à–µ –≤—Å–µ—Ö.",
    "–í—ã –∑–Ω–∞–ª–∏? –ü—ã–ª—å –≤–Ω—É—Ç—Ä–∏ –∫–æ—Ä–ø—É—Å–∞ ‚Äî –∏–¥–µ–∞–ª—å–Ω—ã–π —Ç–µ–ø–ª–æ–∏–∑–æ–ª—è—Ç–æ—Ä (—ç—Ç–æ –ø–ª–æ—Ö–æ).",
    "–§–∞–∫—Ç: Anydesk ID –ª—É—á—à–µ –ø–æ–º–Ω–∏—Ç—å, —á–µ–º –∏—Å–∫–∞—Ç—å –≤ –ø–∞–Ω–∏–∫–µ.",
    "–í—ã –∑–Ω–∞–ª–∏? –ß–µ–º –±–æ–ª—å—à–µ RGB, —Ç–µ–º –±–æ–ª—å—à–µ FPS (–ø–æ—á—Ç–∏).",
    "–õ–∞–π—Ñ—Ö–∞–∫: –ö–Ω–æ–ø–∫–∞ –ø–∏—Ç–∞–Ω–∏—è ‚Äî —ç—Ç–æ –Ω–µ –∫–Ω–æ–ø–∫–∞ '—Ä–µ—à–∏—Ç—å –≤—Å—ë'.",
    "–§–∞–∫—Ç: –ï—Å–ª–∏ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç ‚Äî –ø—Ä–æ–≤–µ—Ä—å –∫–∞–±–µ–ª—å.",
    "–í—ã –∑–Ω–∞–ª–∏? –≠—Ç–æ—Ç –±–æ—Ç –ª—é–±–∏—Ç –≤–∞—à–∏ –ø–∞–∫–µ—Ç—ã (WoL –ø–∞–∫–µ—Ç—ã).",
    "–§–∞–∫—Ç: –ò–Ω–æ–≥–¥–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä –≤—ã–∫–ª—é—á–µ–Ω. –ò–º–µ–Ω–Ω–æ –ø–æ—ç—Ç–æ–º—É –≤—ã –µ–≥–æ –Ω–µ –≤–∏–¥–∏—Ç–µ –≤ —Å–µ—Ç–∏.",
]

def setup_logging(log_file: Path) -> None:
    logger.setLevel(logging.INFO)
    fmt = logging.Formatter("%(asctime)s %(levelname)s %(name)s: %(message)s")
    try:
        handler = logging.handlers.RotatingFileHandler(str(log_file), maxBytes=1_000_000, backupCount=3)
        handler.setFormatter(fmt)
        logger.addHandler(handler)
    except Exception:
        pass
    console = logging.StreamHandler()
    console.setFormatter(fmt)
    logger.addHandler(console)

def restrict_access(allowed_ids: List[int]):
    def decorator(func):
        async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE):
            uid = update.effective_user.id if update.effective_user else None
            if uid not in allowed_ids:
                logger.warning("Unauthorized access attempt from %s", uid)
                try:
                    if update.effective_message:
                        await update.effective_message.reply_text("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")
                except Exception:
                    pass
                return
            return await func(update, context)
        return wrapper
    return decorator

def main_menu_keyboard(hosts: List[Host]) -> InlineKeyboardMarkup:
    rows: List[List[InlineKeyboardButton]] = []
    for h in hosts:
        rows.append([InlineKeyboardButton(h.name, callback_data=f"host:{h.name}")])
    return InlineKeyboardMarkup(rows + [[InlineKeyboardButton("–û–±–Ω–æ–≤–∏—Ç—å", callback_data="refresh_root")]])

def host_menu_keyboard(host: Host, notifications: bool) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("–í–∫–ª—é—á–∏—Ç—å (WoL)", callback_data=f"wake:{host.name}")],
        [InlineKeyboardButton("–°—Ç–∞—Ç—É—Å", callback_data=f"status:{host.name}")],
        [InlineKeyboardButton(
            "–û—Ç–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è" if notifications else "–í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è",
            callback_data=f"toggle_notify:{host.name}"
        )],
        [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="back")],
    ])

async def ping_host(ip: Optional[str]) -> bool:
    if not ip:
        return False
    cmd = ["ping", "-c", "1", "-W", "1", ip]
    try:
        proc = await asyncio.create_subprocess_exec(*cmd, stdout=asyncio.subprocess.DEVNULL, stderr=asyncio.subprocess.DEVNULL)
        await asyncio.wait_for(proc.communicate(), timeout=3)
        return proc.returncode == 0
    except Exception:
        return False

def random_fact() -> str:
    return "\nüí° " + random.choice(FACTS)

async def wake_host(host: Host) -> str:
    try:
        await send_magic_packet(host.mac, host.broadcast_ip or "255.255.255.255")
        logger.info("Sent WoL to %s (%s) via %s", host.name, host.mac, host.broadcast_ip)
        return f"üì° –ü–∞–∫–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: {host.name}" + random_fact()
    except Exception as e:
        logger.exception("WoL failed for %s: %s", host.name, e)
        return f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–∞–∫–µ—Ç {host.name}: {e}" + random_fact()

async def status_text(host: Host) -> str:
    online = await ping_host(host.ip)
    base = f"–°—Ç–∞—Ç—É—Å {host.name}: {'üü¢ –í–ö–õ' if online else 'üî¥ –í–´–ö–õ'}"
    if host.anydesk_id:
        base += f"\nAnydesk: {host.anydesk_id}"
    return base + random_fact()

async def handle_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    settings: Settings = context.bot_data["settings"]
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø—å—é—Ç–µ—Ä:", reply_markup=main_menu_keyboard(settings.hosts)
    )

async def handle_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    settings: Settings = context.bot_data["settings"]
    query = update.callback_query
    await query.answer()
    data = query.data or ""
    notifications: Dict[str, bool] = context.bot_data.setdefault("notifications", {})
    if data == "refresh_root" or data == "back":
        await safe_edit(query, "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø—å—é—Ç–µ—Ä:", main_menu_keyboard(settings.hosts))
        return
    if data.startswith("host:"):
        name = data.split(":", 1)[1]
        host = next((h for h in settings.hosts if h.name == name), None)
        if not host:
            await safe_edit(query, "–•–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", main_menu_keyboard(settings.hosts))
            return
        await safe_edit(query, f"{host.name}: –≤—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ", host_menu_keyboard(host, notifications.get(host.name, False)))
        return
    try:
        action, name = data.split(":", 1)
    except ValueError:
        await safe_edit(query, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ", main_menu_keyboard(settings.hosts))
        return
    host = next((h for h in settings.hosts if h.name == name), None)
    if not host:
        await safe_edit(query, "–•–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", main_menu_keyboard(settings.hosts))
        return
    if action == "wake":
        msg = await wake_host(host)
        context.application.create_task(schedule_one_time_status(query, host, context))
        await safe_edit(query, msg, host_menu_keyboard(host, notifications.get(host.name, False)))
        return
    if action == "status":
        msg = await status_text(host)
        await safe_edit(query, msg, host_menu_keyboard(host, notifications.get(host.name, False)))
        return
    if action == "toggle_notify":
        enabled = notifications.get(host.name, False)
        if enabled:
            notifications[host.name] = False
            await safe_edit(query, f"–ê–≤—Ç–æ—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—ã–∫–ª—é—á–µ–Ω—ã –¥–ª—è {host.name}", host_menu_keyboard(host, False))
        else:
            notifications[host.name] = True
            start_periodic_task(context, host.name)
            await safe_edit(query, f"–ê–≤—Ç–æ—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã –¥–ª—è {host.name}", host_menu_keyboard(host, True))
        return
    await safe_edit(query, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ", main_menu_keyboard(settings.hosts))

async def schedule_one_time_status(query, host: Host, context: ContextTypes.DEFAULT_TYPE):
    await asyncio.sleep(30)
    online = await ping_host(host.ip)
    text = (
        f"{host.name}: üü¢ –£–°–ü–ï–®–ù–û –í–ö–õ–Æ–ß–ï–ù ‚Äî –º–æ–∂–µ—Ç–µ –ø–æ–¥–∫–ª—é—á–∞—Ç—å—Å—è —á–µ—Ä–µ–∑ Anydesk {host.anydesk_id}" if (online and host.anydesk_id) else
        f"{host.name}: üü¢ –£–°–ü–ï–®–ù–û –í–ö–õ–Æ–ß–ï–ù" if online else f"{host.name}: üî¥ –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤–∫–ª—é—á–µ–Ω–∏–µ"
    ) + random_fact()
    try:
        await query.message.reply_text(text)
    except Exception:
        pass

def start_periodic_task(context: ContextTypes.DEFAULT_TYPE, host_name: str):
    periodic_tasks: Dict[str, asyncio.Task] = context.bot_data.setdefault("periodic_tasks", {})
    if host_name in periodic_tasks and not periodic_tasks[host_name].done():
        return
    task = context.application.create_task(periodic_status_loop(context, host_name))
    periodic_tasks[host_name] = task

async def periodic_status_loop(context: ContextTypes.DEFAULT_TYPE, host_name: str):
    settings: Settings = context.bot_data["settings"]
    notifications: Dict[str, bool] = context.bot_data.get("notifications", {})
    host = next((h for h in settings.hosts if h.name == host_name), None)
    if not host:
        return
    while notifications.get(host_name, False):
        await asyncio.sleep(3600)
        if not notifications.get(host_name, False):
            break
        online = await ping_host(host.ip)
        if online:
            text = (
                f"–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–æ–º–∏–Ω–∞—é, –∫–æ–º–ø—å—é—Ç–µ—Ä {host.name} –≤–∫–ª—é—á—ë–Ω ‚Äî –º–æ–∂–µ—Ç–µ –ø–æ–¥–∫–ª—é—á–∞—Ç—å—Å—è —á–µ—Ä–µ–∑ Anydesk"
                + (f" {host.anydesk_id}" if host.anydesk_id else "")
            )
        else:
            text = f"–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–æ–º–∏–Ω–∞—é, –∫–æ–º–ø—å—é—Ç–µ—Ä {host.name} —Å–µ–π—á–∞—Å –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç." + random_fact()
        for uid in settings.allowed_ids:
            try:
                await context.bot.send_message(chat_id=uid, text=text)
            except Exception:
                pass

async def safe_edit(query, text: str, markup: InlineKeyboardMarkup):
    try:
        current = query.message.text if query.message else None
        if current == text:
            await query.edit_message_reply_markup(reply_markup=markup)
        else:
            await query.edit_message_text(text, reply_markup=markup)
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.warning("Edit failed: %s", e)
    except Exception as e:
        logger.warning("Edit exception: %s", e)

def main() -> None:
    settings = load_settings()
    setup_logging(settings.log_file)
    logger.info("Starting WoL bot with %d hosts", len(settings.hosts))
    app = Application.builder().token(settings.tg_token).build()
    app.bot_data["settings"] = settings
    app.bot_data["notifications"] = {}
    app.bot_data["periodic_tasks"] = {}
    app.add_handler(CommandHandler("start", restrict_access(settings.allowed_ids)(handle_start)))
    app.add_handler(CallbackQueryHandler(restrict_access(settings.allowed_ids)(handle_buttons)))
    app.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    main()
